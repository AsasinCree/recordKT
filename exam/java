面向对象的三大特性：封装、继承、多态

多态
  定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式
  作用：消除类型之间的耦合关系
  实现多态的技术：动态绑定（dynamic binding），是指在运行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。（编译时类型和运行时类型不一致，就会出现所谓的多态）
  举例：F1 键。在 Word 下弹出 Word 帮助；在 Windows 下弹出 Windows 帮助和支持
  多态存在的三个必要条件
    要有继承；
    要有重写/覆写；
    父类引用指向子类对象。
  子类转型为父类的规则：
    只能调用父类的属性
    只能调用父类未被覆写的方法
    只能调用被子类覆写的方法
    
多线程编程
  实现手段：
    继承Thread类：（多个对象之间）资源非共享[当然也可以用同步来实现]
    实现Runable接口：资源共享[new Thread()方法的Runnable为同一个才行]
  在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾回收线程。
  Thread类的方法：sleep(),yield()等 
  Object的方法：wait()和notify()等 
  sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 
  wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
  isAlive(): 判断一个线程是否存活。
  currentThread(): 得到当前线程
  后台线程：指为其他线程提供服务的线程，也称为守护线程。如垃圾回收线程。用户线程和守护线程的区别在于，是否依赖于主线程结束而结束
  isDaemon(): 一个线程是否为守护线程
  synchronized关键字加在方法上还是对象上，它取得的锁都是对象。每个对象只有一个锁（lock）与之相关联。
  对于静态同步方法，锁是针对这个类的。静态和非静态方法的锁互不干预
  线程数据传递
    构造方法
    public的方法或变量
    使用回调函数：http://blog.csdn.net/xiaanming/article/details/8703708/（java回调机制）
  【图片截取】http://blog.csdn.net/escaflone/article/details/10418651
  java中的锁：java.util.concurrent.locks【参考印象笔记java线程网址】
    一个可重入锁（reentrant lock）的简单实现：
      public class Lock {
          boolean isLocked = false;
          Thread  lockedBy = null;
          int lockedCount = 0;
      
          public synchronized void lock() throws InterruptedException{
              Thread callingThread = Thread.currentThread();
              while(isLocked && lockedBy != callingThread){
                  wait();
              }
              isLocked = true;
              lockedCount++;
              lockedBy = callingThread;
          }
      
          public synchronized void unlock(){
              if(Thread.currentThread() == this.lockedBy){
                  lockedCount--;
                  if(lockedCount == 0){
                      isLocked = false;
                      notify();
                  }
              }
          }
      }
     
      注意的一点：在finally语句中调用unlock()
      lock.lock();
      try{
          //do critical section code, which may throw exception
      } finally {
          lock.unlock();
      }
      
  java中其他同步方法
    信号量（Semaphore）：java.util.concurrent.Semaphore
    阻塞队列（Blocking Queue）：java.util.concurrent.BlockingQueue
      public class BlockingQueue {
        private List queue = new LinkedList();
        private int limit = 10;
    
        public BlockingQueue(int limit) {
            this.limit = limit;
        }
    
        public synchronized void enqueue(Object item) throws InterruptedException {
            while (this.queue.size() == this.limit) {
                wait();
            }
            if (this.queue.size() == 0) {
                notifyAll();
            }
            this.queue.add(item);
        }
    
        public synchronized Object dequeue() throws InterruptedException {
            while (this.queue.size() == 0) {
                wait();
            }
            if (this.queue.size() == this.limit) {
                notifyAll();
            }
            return this.queue.remove(0);
        }
      }
      
  java中的线程池：http://ifeve.com/java-threadpool/
    Java通过Executors提供四种线程池，分别为：
      newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
      newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
      newScheduledThreadPool：创建一个大小无限制的线程池。此线程池支持定时以及周期性执行任务。
      newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
      
      
  
