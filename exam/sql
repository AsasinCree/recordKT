实体完整性要求每一个表中的主键字段都不能为空或者重复的值。实体完整性指表中行的完整性。要求表中的所有行都有唯一的标识符，称为主关键字。
参照的完整性要求关系中不允许引用不存在的实体。当更新、删除、插入一个表中的数据时，通过参照引用相互关联的另一个表中的数据，来检查对表的数据操作是否正确
例如，如果在学生表和选修课之间用学号建立关联，学生表是主表，选修课是从表，那么，在向从表中输入一条新记录时，系统要检查新记录的学号是否在主表中已存在，如果存在，则允许执行输入操作，否则拒绝输入，这就是参照完整性。
参照完整性还体现在对主表中的删除和更新操作，例如，如果删除主表中的一条记录，则从表中凡是外键的值与主表的主键值相同的记录也会被同时删除，将此称为级联删除；如果修改主表中主关键字的值，则从表中相应记录的外键值也随之被修改，将此称为级联更新

索引是对数据库表中一个或多个列的值进行排序的结构

索引分为聚簇索引和非聚簇索引两种：
聚集（聚簇）索引指主索引文件和数据文件为同一份文件，表数据按照索引的顺序来存储的
非聚集（聚簇）索引指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址
聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快

根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。
  唯一索引：不允许其中任何两行具有相同索引值的索引。
  主键索引：数据库表经常有一列或多列组合，其值唯一标识表中的每一行。
  聚集（聚簇）索引：表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引（真实物理地址顺序只能有一种）。

索引好处
通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
加快数据的检索速度
加速表和表之间的连接
减少查询中分组和排序的时间

建立太多的索引将会影响更新和插入的速度

应该在这些列上创建索引：
  主键列
  外键列
  排序列
  where条件查询列
  
最普通的情况，是为出现在where子句的字段建一个索引。为方便讲述，先建立一个如下的表。
CREATE TABLE mytable(
idserial int primary key,
category_id int not null default 0,
user_id int not null default 0,
adddate int not null default 0
);
如果在查询时常用类似以下的语句：
SELECT * FROM mytable WHERE category_id=1;
最直接的应对之道，是为category_id建立一个简单的索引：
CREATE INDEX mytable_categoryid ON mytable (category_id);
OK.如果有不止一个选择条件呢？例如：
SELECT * FROM mytable WHERE category_id=1 AND user_id=2;
第一反应可能是，再给user_id建立一个索引。不好，这不是一个最佳的方法。可以建立多重的索引。
CREATE INDEX mytable_categoryid_userid ON mytable(category_id,user_id);
注意到在命名时的习惯了吗？使用"表名_字段1名_字段2名"的方式。很快就会知道为什么这样做了。
现在已经为适当的字段建立了索引，不过，还是有点不放心吧，可能会问，数据库会真正用到这些索引吗？测试一下就OK，对于大多数的数据库来说，这是很容易的，只要使用EXPLAIN命令：
EXPLAIN
SELECT * FROM mytable
WHERE category_id=1 AND user_id=2;
This is what Postgres 7.1 returns (exactlyasI expected)
NOTICE:QUERY PLAN:
Index Scan using mytable_categoryid_userid on
mytable(cost=0.00..2.02 rows=1 width=16)
EXPLAIN
以上是postgres的数据，可以看到该数据库在查询的时候使用了一个索引（一个好开始），而且它使用的是创建的第二个索引。看到上面命名的好处了吧，马上知道它使用适当的索引了。
接着，来个稍微复杂一点的，如果有个ORDERBY 子句呢？不管你信不信，大多数的数据库在使用orderby的时候，都将会从索引中受益。
SELECT * FROM mytable
WHERE category_id=1 AND user_id=2
ORDER BY adddate DESC;
很简单，就像为where子句中的字段建立一个索引一样，也为ORDER BY的子句中的字段建立一个索引：
CREATE INDEX mytable_categoryid_userid_adddate ON mytable (category_id,user_id,adddate);
注意:"mytable_categoryid_userid_adddate"将会被截短为"mytable_categoryid_userid_addda"
CREATE
EXPLAIN SELECT * FROM mytable
WHERE category_id=1 AND user_id=2
ORDER BY adddate DESC;
NOTICE:QUERY PLAN:
Sort(cost=2.03..2.03 rows=1 width=16)
->Index Scanusing mytable_categoryid_userid_addda
on mytable(cost=0.00..2.02 rows=1 width=16)
EXPLAIN
看看EXPLAIN的输出，数据库多做了一个没有要求的排序，这下知道性能如何受损了吧，看来对于数据库的自身运作是有点过于乐观了，那么，给数据库多一点提示吧。
为了跳过排序这一步，并不需要其它另外的索引，只要将查询语句稍微改一下。这里用的是postgres，将给该数据库一个额外的提示--在ORDER BY语句中，加入where语句中的字段。这只是一个技术上的处理，并不是必须的，因为实际上在另外两个字段上，并不会有任何的排序操作，不过如果加入，postgres将会知道哪些是它应该做的。
EXPLAIN SELECT * FROM mytable
WHERE category_id=1 AND user_id=2
ORDER BY category_id DESC,user_id DESC,adddate DESC;
NOTICE:QUERY PLAN:
Index Scan Backward using
mytable_categoryid_userid_addda on mytable(cost=0.00..2.02 rows=1 width=16)
EXPLAIN
现在使用料想的索引了，而且它还挺聪明，知道可以从索引后面开始读，从而避免了任何的排序。




B-tree（B-树）原理讲解：http://www.it165.net/database/html/201411/9079.html
二叉树、B-树、B+树、B*树区分：http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html
